/**
 * This file owns persistence for Publish V1 internal memory. It exists because the
 * capability layer needs idempotent behavior but should not hand-roll JSON file
 * management repeatedly.
 *
 * It talks to the filesystem and cryptographic hashing utilities, and it is called by
 * all capabilities that read or mutate diagrams/rows.
 */
import { createHash } from "node:crypto";
import { mkdir, readdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import {
  type DiagramRecord,
  type PlanState,
  type ProjectPaths
} from "../contracts/types.js";
import { assertWriteTarget } from "./project-paths.js";

const STATE_VERSION = "1.0.0";

function nowIso(): string {
  return new Date().toISOString();
}

export function computeContentHash(content: string): string {
  return createHash("sha256").update(content).digest("hex");
}

function buildDefaultState(paths: ProjectPaths, sourceFile = "", essayHash = ""): PlanState {
  return {
    version: STATE_VERSION,
    projectPath: paths.projectRoot,
    sourceFile,
    essayHash,
    rows: [],
    diagrams: [],
    warnings: [],
    updatedAt: nowIso()
  };
}

export async function ensureArtifactsStructure(paths: ProjectPaths): Promise<void> {
  assertWriteTarget(paths, paths.artifactsDir);
  assertWriteTarget(paths, paths.internalDir);

  await mkdir(paths.artifactsDir, { recursive: true });
  await mkdir(paths.internalDir, { recursive: true });
}

export async function loadPlanState(
  paths: ProjectPaths,
  sourceFile = "",
  essayHash = ""
): Promise<PlanState> {
  await ensureArtifactsStructure(paths);

  try {
    const raw = await readFile(paths.stateFile, "utf8");
    const parsed = JSON.parse(raw) as PlanState;

    // We migrate lightweight metadata at read time so old state remains usable.
    return {
      ...parsed,
      version: parsed.version || STATE_VERSION,
      projectPath: parsed.projectPath || paths.projectRoot,
      sourceFile: parsed.sourceFile || sourceFile,
      essayHash: parsed.essayHash || essayHash,
      rows: parsed.rows || [],
      diagrams: parsed.diagrams || [],
      warnings: parsed.warnings || [],
      updatedAt: parsed.updatedAt || nowIso()
    };
  } catch {
    return buildDefaultState(paths, sourceFile, essayHash);
  }
}

export async function savePlanState(paths: ProjectPaths, state: PlanState): Promise<void> {
  state.updatedAt = nowIso();
  state.version = STATE_VERSION;

  assertWriteTarget(paths, paths.stateFile);
  await writeFile(paths.stateFile, `${JSON.stringify(state, null, 2)}\n`, "utf8");
}

export function appendWarnings(state: PlanState, warnings: string[]): void {
  const seen = new Set(state.warnings);
  for (const warning of warnings) {
    if (!seen.has(warning)) {
      state.warnings.push(warning);
      seen.add(warning);
    }
  }
}

export async function nextDiagramFilename(paths: ProjectPaths, state: PlanState): Promise<string> {
  const knownIndices = new Set<number>();

  for (const diagram of state.diagrams) {
    const match = diagram.filename.match(/^diagram-(\d+)\.excalidraw$/);
    if (match) {
      knownIndices.add(Number(match[1]));
    }
  }

  const artifactFiles = await readdir(paths.artifactsDir).catch(() => []);
  for (const file of artifactFiles) {
    const match = file.match(/^diagram-(\d+)\.excalidraw$/);
    if (match) {
      knownIndices.add(Number(match[1]));
    }
  }

  const max = knownIndices.size > 0 ? Math.max(...knownIndices) : 0;
  const next = max + 1;
  return `diagram-${String(next).padStart(2, "0")}.excalidraw`;
}

export function upsertDiagram(state: PlanState, record: DiagramRecord): void {
  const existingIndex = state.diagrams.findIndex((entry) => entry.id === record.id);

  if (existingIndex === -1) {
    state.diagrams.push(record);
    return;
  }

  state.diagrams[existingIndex] = record;
}

export function findDiagram(
  state: PlanState,
  identifier: string
): DiagramRecord | undefined {
  const normalized = identifier.endsWith(".excalidraw") ? identifier : `${identifier}.excalidraw`;

  return state.diagrams.find(
    (entry) => entry.id === identifier || entry.filename === identifier || entry.filename === normalized
  );
}

export async function writeDiagramLinks(paths: ProjectPaths, state: PlanState): Promise<void> {
  const lines: string[] = [];
  lines.push("# Diagram Links");
  lines.push("");
  lines.push(
    "This file is generated by Press Publish V1. It records web links when they are available and keeps local-first continuity when they are not."
  );
  lines.push("");

  if (state.diagrams.length === 0) {
    lines.push("No diagrams have been created yet.");
  } else {
    for (const diagram of state.diagrams) {
      const localPath = path.join("artifacts", diagram.filename);
      if (diagram.webUrl) {
        lines.push(`- ${diagram.filename}: ${diagram.webUrl} (local: ${localPath})`);
      } else {
        lines.push(
          `- ${diagram.filename}: web link unavailable in this run; local file is source of truth (${localPath}).`
        );
      }
    }
  }

  if (state.warnings.length > 0) {
    lines.push("");
    lines.push("## Warnings");
    lines.push("");
    for (const warning of state.warnings) {
      lines.push(`- ${warning}`);
    }
  }

  assertWriteTarget(paths, paths.linksFile);
  await writeFile(paths.linksFile, `${lines.join("\n")}\n`, "utf8");
}
