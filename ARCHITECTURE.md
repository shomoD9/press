# Press Architecture

## The Opening
Press is a deterministic animation system whose center of gravity is craft, not convenience. The project exists to convert beat-level narrative intent into premium motion graphics that can be previewed quickly, iterated scene by scene, and rendered into reproducible MP4 outputs. The system is intentionally narrow in V1. It does not attempt to solve stock sourcing, transcription workflows, or generalized editor UX. It concentrates on the animation engine itself and enforces quality gates before rendering so visual output remains deliberate, minimalistic, and high fidelity.

The working model is artifact-first. A user, often through Codex collaboration, edits structured JSON artifacts that describe project settings, scene intent, and style constraints. The runtime interprets those artifacts through typed schemas, compiles them into frame timelines, renders through Remotion and FFmpeg, and writes render manifests that preserve reproducibility. This architecture keeps the creative contract legible while preserving engineering discipline over timing and output stability.

## The Ontology
The first fundamental entity is the project specification. A project carries identity, render geometry, frame rate, style reference, and an ordered list of scenes. The second fundamental entity is the scene specification. A scene is the atomic unit of meaning and timing, including beat range, treatment type, duration, layer timing, camera keyframes, and text intent. The third fundamental entity is style tokens. Style tokens define the visual constitution for an entire video through palette, typography, spacing, motion profile, texture policy, and contrast safety thresholds.

Around these three entities, the engine defines operational actors. The schema validator judges whether artifacts are structurally and semantically acceptable. The compiler translates accepted scenes into timeline offsets. The scene registry resolves treatment identifiers into executable scene kits. Motion helpers provide deterministic timing and seeded randomness primitives. The quality linter applies craft policy to catch density, contrast, and camera problems before render. The renderer bundles the composition entry, renders either a scene or the full project, and emits a manifest so outputs remain auditable.

## The Geography
At the project root, `package.json` declares the runtime surface and the `press` command scripts, while `tsconfig.json`, `vitest.config.ts`, and `remotion.config.ts` define compilation, testing, and rendering defaults. `README.md` gives operational command guidance. `ARCHITECTURE.md` narrates the system map and `DEVLOG.md` records execution history. `SCOPE.md` and `docs/v2-video-production-engine.md` hold product intent, and `docs/carftsmanship.md` holds visual quality principles. `.gitignore` excludes generated and local-only artifacts, and `public/placeholder.txt` anchors static-asset routing expectations for Remotion.

The `schemas/` directory is where contracts live. `schemas/style-tokens.ts` defines visual token structure, `schemas/scene-spec.ts` defines scene shape, `schemas/project-spec.ts` defines project shape, and `schemas/validate-project.ts` adds cross-entity invariants such as beat overlap and keyframe ordering. `schemas/index.ts` exposes a single import surface for the rest of the system.

The `engine/` directory is the executable core. `engine/motion/frame-math.ts` and `engine/motion/deterministic.ts` provide timing and seeded-random primitives, collected by `engine/motion/index.ts`. `engine/scenes/` contains one file per treatment: `kinetic-typography-scene.tsx`, `concept-network-scene.tsx`, `comparison-split-scene.tsx`, `abstract-geometric-scene.tsx`, and `text-emphasis-card-scene.tsx`. `engine/scenes/types.ts` defines scene render contracts, and `engine/scenes/registry.tsx` maps treatment names to components. `engine/compiler/compile-project.ts` computes timeline offsets and scene lookup behavior, with `engine/compiler/index.ts` as the external surface. `engine/quality/contrast.ts` performs luminance math, `engine/quality/lint-craft.ts` applies craft policy rules, and `engine/quality/index.ts` exports quality APIs. `engine/render/render-project.ts` and `engine/render/render-scene.ts` orchestrate Remotion rendering, while `engine/render/render-utils.ts` handles spec hashing, output directories, and manifest writing, all re-exported by `engine/render/index.ts`. `engine/remotion/` is the composition runtime: `composition-ids.ts` provides stable composition constants for CLI and renderer use, `types.ts` defines input props, `project-composition.tsx` handles full timelines, `scene-composition.tsx` handles isolated scene iteration, `root.tsx` registers dynamic metadata-backed compositions, and `index.ts` registers the root with Remotion.

The `scene-kits/common/` directory contains reusable visual infrastructure used across scene treatments. `scene-kits/common/backdrop.tsx` defines cinematic background behavior and `scene-kits/common/typography-block.tsx` defines reusable text hierarchy rendering. The `scripts/` directory exposes operations to the user. `scripts/press.ts` is the CLI entrypoint for validation, preview, and render commands, while `scripts/shared/io.ts` and `scripts/shared/load-project.ts` provide shared JSON and artifact-loading utilities.

The `artifacts/projects/demo-v1/` directory contains the bundled example that proves the pipeline contract, with `project.spec.json` and `style.tokens.json` as concrete inputs. The `renders/` directory is intentionally empty in source control and is reserved for generated outputs and render manifests. The `tests/` directory contains unit-level gates: `validate-project.test.ts`, `compiler.test.ts`, `deterministic.test.ts`, and `lint-craft.test.ts`. Finally, `examples-replit-research/` is retained as untracked research material and is not in the runtime path.

## The Flow
A normal run begins in `scripts/press.ts`, where the command layer resolves a project reference and loads its JSON artifacts through `scripts/shared/load-project.ts`. Validation happens first by calling `validateProjectArtifacts` from `schemas/validate-project.ts`. If schema parsing or cross-scene checks fail, execution stops immediately with concrete issue paths, because all downstream work assumes reliable contracts.

When preview is requested, the CLI launches Remotion Studio through a child process and passes serialized input props, choosing either the full project composition or the single-scene composition. In the full composition path, `engine/remotion/project-composition.tsx` calls the compiler and then renders each scene through `Sequence` segments based on start frame offsets. In the scene composition path, `engine/remotion/scene-composition.tsx` resolves one scene by identifier and renders only that treatment for fast iteration.

When rendering is requested, the command layer runs craft lint through `engine/quality/lint-craft.ts` and blocks if errors are present unless `--force` is explicitly provided. If quality gates pass, the renderer layer bundles `engine/remotion/index.ts`, selects the target composition, renders MP4 output, and writes `render-manifest.json` with render metadata and a deterministic spec hash. The output is placed in a timestamped subdirectory inside `renders/<project-id>/`, which makes each render artifact immutable and traceable.

## The Philosophy
The architecture values deterministic frame logic over browser animation convenience because V1 is judged by reproducible render quality. That is why the project does not use GSAP, anime.js, or Framer Motion as the render-time engine. Those libraries are excellent for interactive web motion, but the V1 contract requires stable frame-by-frame output controlled by Remotion and typed artifacts.

The second guiding choice is separation between intent and execution. JSON artifacts express what should happen, while scene-kit code expresses how it happens. This keeps collaboration natural with Codex while preserving strict engineering guardrails over timing, style consistency, and render determinism. The third guiding choice is gatekeeping quality before cost. Validation and craft lint run before heavy rendering so the system rejects malformed or low-standard work early, preserving both computation time and aesthetic integrity.
