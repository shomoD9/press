# Opening

Press is a local-first production system for a creator who thinks in essays and works inside Obsidian. The system is designed around a simple promise: the creator should express intent in natural language to an agent, and Press should translate that intent into stable, repeatable artifacts inside the correct project folder. Publish V1 is the first concrete expression of that promise. It turns source markdown into a usable visual production plan and diagram assets, so video assembly becomes execution rather than improvisation.

The architectural center of gravity is not a web interface but a contract between conversation and deterministic execution. Chat remains the human interface, while the runtime produces concrete files with strict boundaries. This separation is deliberate. It allows fluid iteration in conversation without sacrificing reliability, traceability, or repeatability in the actual outputs.

# Ontology

The most important object in Press is a project workspace under a creative vault category such as `Essays` or `Commentary`. A project contains source markdown that represents evolving argument material, and it contains an `artifacts` directory where Publish V1 stores generated production outputs. Each generated visual action is represented as a plan row, and each diagram file is represented as a persistent record with identity and revision history. This makes iteration stable, because a refinement operation updates a known artifact rather than spawning uncontrolled copies.

A second core object is internal state, stored as `plan-state.json` under `.press`. This state is the memory that holds row identities, diagram mappings, hashes, and warning history. It is intentionally private to the runtime so a user can operate at the level of conversation and markdown artifacts while the system enforces idempotency and consistency under the hood. A third core object is wiring, stored in vault `_system` files. Wiring is the declarative map that tells agents how to route natural-language requests to deterministic capabilities. Without this wiring, capabilities exist but remain a manual backend; with wiring, they become product behavior.

# Geography

At the repository root, `README.md` now acts as operational front door, explaining one-command install, one-command upgrade, and health checks. `ARCHITECTURE.md` is this living system narrative and must always match runtime reality. `CLAUDE.md` remains high-level product context for agents. `package.json` exposes lifecycle commands including `bootstrap`, `update`, `doctor`, `release:tag`, and `install:wiring`, while `.gitignore` excludes build artifacts and local install metadata such as `.press-local.json`.

The `src` directory contains runtime behavior. `src/index.ts` is the dispatch layer that normalizes command syntax and routes requests to capabilities. The `src/capabilities` directory contains user-facing operations in `diagram-create.ts`, `diagram-refine.ts`, `plan-generate.ts`, and `plan-validate.ts`. The `src/io` directory contains filesystem and parsing primitives in `project-paths.ts`, `markdown.ts`, `state.ts`, and `plan-render.ts`. The `src/contracts` directory contains shared types and runtime schema checks in `types.ts` and `schema.ts`. The `src/integrations/excalidraw.ts` file is the boundary for diagram tooling and fallback behavior.

The `scripts` directory now defines product delivery behavior. `scripts/bootstrap.sh` performs one-command setup and installs persistent wiring. `scripts/update.sh` performs stable-channel upgrade by tag, rebuilds, retests, and refreshes wiring. `scripts/doctor.sh` validates environment, runtime artifacts, command shim presence, vault wiring health, and Excalidraw bridge readiness. `scripts/release-tag.sh` enforces release discipline by validating cleanliness, running tests, creating annotated tags, optionally pushing tags, and generating release-note stubs. The `scripts/install-wiring.ts` program is the wiring engine that writes `_system/press-wiring.md` from a template and idempotently injects marker blocks into `_system/CLAUDE.md` and `_system/AGENTS.md` while also creating or updating root-level instruction files such as `CLAUDE.md`, `AGENTS.md`, `WARP.md`, `CODEX.md`, and `CURSOR.md` for agents that only inspect project roots. The `scripts/excalidraw-mcp-bridge.ts` program is the first-party MCP client boundary that speaks JSON-RPC over stdio to an Excalidraw MCP server and returns normalized create/refine payloads to Press.

The `templates` directory contains `templates/press-wiring.md`, the canonical cross-agent wiring contract rendered into user vaults. The `docs` directory contains long-form product intent and usage guidance. `docs/capabilities/publish-v1.md` now describes no-manual-CLI operating mode and mapping contracts. Existing product scope documents remain in `docs/spec-v1-visual-plan.md`, `docs/spec-v2-write-module.md`, `docs/roadmap.md`, and `docs/visual-trigger-ruleset.md`. The roadmap now explicitly includes a post-V5 milestone for in-vault installation and update UX so future delivery can remove terminal-first friction from onboarding and maintenance. The `docs/releases` directory is reserved for release-note stubs created during tag workflows.

The `tests` directory provides verification. `tests/fixtures/creative` models realistic vault structures for essays and commentary projects with `_system` trigger rules. `tests/fixtures/mcp/mock-excalidraw-mcp-server.js` simulates MCP protocol behavior so bridge tests remain deterministic and do not depend on external infrastructure. `tests/publish-v1` contains behavior tests for diagram creation, refinement, plan generation, validation, project-path safety, wiring installer behavior through deterministic fixture workspaces, and protocol-level bridge checks for Excalidraw create/refine routing.

# Flow

A normal user session starts in Obsidian and agent chat. The user asks for a diagram, a refinement, a plan generation, or a validation. Agent wiring in vault `_system` files and mirrored root-level instruction files maps that intent to a capability invocation contract. The dispatcher in `src/index.ts` validates the command envelope and forwards it to the correct capability module. Capability logic resolves project-safe paths, reads source markdown, applies trigger heuristics, interacts with the Excalidraw boundary when needed, updates internal state, and writes artifacts to the project `artifacts` directory.

When a diagram capability runs, `src/integrations/excalidraw.ts` first tries an explicitly configured external command, then defaults to the first-party bridge in `scripts/excalidraw-mcp-bridge.ts`. The bridge initializes MCP, discovers tools, selects create/refine operations, and normalizes returned content and link metadata. If the MCP command is missing or unavailable, the adapter records a warning and still writes a local diagram artifact so writing flow never blocks.

Installation and lifecycle flow begins with `npm run bootstrap -- --vault <creative-path>`. The bootstrap script validates local prerequisites, installs dependencies, compiles and tests the runtime, installs a local `press` command shim, executes wiring installation for the target vault, and runs doctor checks. From that point onward, the user can stay in natural language while the system uses deterministic execution behind the scenes. Upgrade flow uses `npm run update`, which fetches stable tags, checks out the newest stable tag in detached mode, rebuilds, retests, and refreshes vault wiring idempotently. Health flow uses `npm run doctor`, which verifies runtime and wiring integrity before a writing session. Maintainer flow uses `npm run release:tag -- --version vX.Y.Z` to enforce clean release tagging and generate release-note scaffolding.

# Philosophy

Press favors deterministic local behavior over orchestration magic. The system assumes external tools can fail or evolve, so it treats local artifacts as the source of truth and records warnings instead of quietly losing state. That philosophy appears in Excalidraw fallback behavior, stateful idempotency, and strict path guards that prevent writes outside project artifacts.

Press also treats wiring as product, not documentation garnish. A capability that exists only as a command is not enough for this audience; the audience needs natural-language operation that feels immediate. The wiring subsystem closes that gap by making conversation reliably executable. Finally, Press uses release discipline to protect creative flow. Stable tags, one-command upgrades, doctor checks, and rollback visibility reduce operational friction so writing sessions are not derailed by tool uncertainty.
