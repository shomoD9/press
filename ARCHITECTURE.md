# Opening

Press is a local-first production system for a creator who thinks in essays and works inside Obsidian. The system is designed around a simple promise: the creator should express intent in natural language to an agent, and Press should translate that intent into stable, repeatable artifacts inside the correct project folder. Publish V1 is the first concrete expression of that promise. It turns source markdown into a usable visual production plan and diagram assets, so video assembly becomes execution rather than improvisation.

V1.5 extends that promise from capability correctness into usability. The runtime remains deterministic and file-bound, but the primary control surface is now an Obsidian plugin shell that triggers install, connection, readiness, generation, update, and rollback actions without terminal interaction in normal use. Chat remains the primary human interface for creative intent, while deterministic scripts remain the execution layer.

# Ontology

The most important object in Press is a project workspace under a creative vault category such as `Essays` or `Commentary`. A project contains source markdown that represents evolving argument material, and it contains an `artifacts` directory where Publish stores generated production outputs. Each generated visual action is represented as a plan row, and each diagram file is represented as a persistent record with identity and revision history. This makes iteration stable, because a refinement operation updates a known artifact rather than spawning uncontrolled copies.

A second core object is internal state, stored as `plan-state.json` under `.press`. This state is the memory that holds row identities, diagram mappings, hashes, and warning history. It is intentionally private to the runtime so a user can operate at the level of conversation and markdown artifacts while the system enforces idempotency and consistency under the hood. A third core object is wiring, stored in vault `_system` files and mirrored root files for multiple agent ecosystems. Wiring is the declarative map that tells agents how to route natural-language requests to deterministic capabilities. Without this wiring, capabilities exist but remain a manual backend; with wiring, they become product behavior. A fourth core object in V1.5 is the article draft package under `artifacts/publish-draft-package`, which materializes publish handoff files for Substack, LessWrong, and X article workflows.

# Geography

At the repository root, `README.md` now acts as an Obsidian-first front door that explains plugin-led setup and backend fallback commands. `ARCHITECTURE.md` is this living system narrative and must always match runtime reality. `CLAUDE.md` remains high-level product context for agents. `package.json` exposes lifecycle commands including `bootstrap`, `connect-services`, `doctor`, `ready-check`, `update`, `rollback`, `release:tag`, and `install:wiring`, while `.gitignore` excludes build artifacts and local install metadata such as `.press-local.json`.

The `src` directory contains runtime behavior. `src/index.ts` is the dispatch layer that normalizes command syntax and routes requests to capabilities. The `src/capabilities` directory contains user-facing operations in `diagram-create.ts`, `diagram-refine.ts`, `plan-generate.ts`, `plan-validate.ts`, and `build-draft-package.ts`. The `src/io` directory contains filesystem and parsing primitives in `project-paths.ts`, `markdown.ts`, `state.ts`, `plan-render.ts`, and `article-package.ts`. The `src/contracts` directory contains shared types and runtime schema checks in `types.ts` and `schema.ts`. The `src/integrations/excalidraw.ts` file is the boundary for diagram tooling and fallback behavior.

The `scripts` directory now defines product delivery behavior. `scripts/bootstrap.sh` performs one-command setup and installs persistent wiring. `scripts/connect-services.ts` writes service configuration and validates Excalidraw connectivity immediately. `scripts/doctor.sh` validates environment, runtime artifacts, command shim presence, vault wiring health, and Excalidraw bridge readiness while emitting binary readiness output with a first-fix action. `scripts/update.sh` performs stable-channel upgrade by tag, rebuilds, retests, refreshes wiring, and stores rollback metadata. `scripts/rollback.sh` restores a previous known-good reference in one command. `scripts/release-tag.sh` enforces release discipline by validating cleanliness, running tests, creating annotated tags, optionally pushing tags, and generating release-note stubs. The `scripts/install-wiring.ts` program is the wiring engine that writes `_system/press-wiring.md` from a template and idempotently injects marker blocks into `_system/CLAUDE.md` and `_system/AGENTS.md` while also creating or updating root-level instruction files such as `CLAUDE.md`, `AGENTS.md`, `WARP.md`, `CODEX.md`, and `CURSOR.md` for agents that only inspect project roots. The `scripts/excalidraw-mcp-bridge.ts` program is the first-party MCP client boundary that speaks JSON-RPC over stdio to an Excalidraw MCP server and returns normalized create/refine payloads to Press.

The `plugins` directory contains `plugins/obsidian-press-v15`, which is the private Obsidian plugin shell for V1.5. It includes `manifest.json`, `main.js`, and plugin-local usage notes for command palette flows. The `templates` directory contains `templates/press-wiring.md`, the canonical cross-agent wiring contract rendered into user vaults with mandatory preflight guidance. The `docs` directory contains long-form product intent and usage guidance. `docs/capabilities/publish-v1.md` describes no-manual-CLI operating mode, command mapping contracts, and V1.5 command surfaces. `docs/functional-requirements-v1.5.md` is the plain-language source-of-truth FRD for usability hardening scope and acceptance standards, and `docs/spec-v1.5-obsidian-first.md` defines the concrete release scope for the Obsidian-first implementation line. Existing product scope documents remain in `docs/spec-v1-visual-plan.md`, `docs/spec-v2-write-module.md`, `docs/roadmap.md`, and `docs/visual-trigger-ruleset.md`. The `docs/releases` directory is reserved for release-note stubs created during tag workflows.

The `tests` directory provides verification. `tests/fixtures/creative` models realistic vault structures for essays and commentary projects with `_system` trigger rules. `tests/fixtures/mcp/mock-excalidraw-mcp-server.js` simulates MCP protocol behavior so bridge tests remain deterministic and do not depend on external infrastructure. `tests/publish-v1` contains behavior tests for diagram creation, refinement, plan generation, validation, draft package generation, project-path safety, wiring installer behavior through deterministic fixture workspaces, and protocol-level bridge checks for Excalidraw create/refine routing.

# Flow

A normal user session starts in Obsidian and agent chat. The user asks for a diagram, a refinement, a plan generation, a validation, or a draft package build. Agent wiring in vault `_system` files and mirrored root-level instruction files maps that intent to a capability invocation contract with preflight checks. The dispatcher in `src/index.ts` validates the command envelope and forwards it to the correct capability module. Capability logic resolves project-safe paths, reads source markdown, applies trigger heuristics, interacts with the Excalidraw boundary when needed, updates internal state, and writes artifacts to the project `artifacts` directory.

When a diagram capability runs, `src/integrations/excalidraw.ts` first tries an explicitly configured external command, then defaults to the first-party bridge in `scripts/excalidraw-mcp-bridge.ts`. The bridge initializes MCP, discovers tools, selects create/refine operations, and normalizes returned content and link metadata. If the MCP command is missing or unavailable, the adapter records a warning and still writes a local diagram artifact so writing flow never blocks.

In V1.5, lifecycle flow can be driven from Obsidian command palette through the private plugin shell. The plugin invokes backend scripts and capabilities in sequence, starting with install or repair, then service connection, then ready check. Backend installation flow still begins with `npm run bootstrap -- --vault <creative-path>` under the hood. The bootstrap script validates local prerequisites, installs dependencies, compiles and tests the runtime, installs a local `press` command shim, executes wiring installation for the target vault, and runs doctor checks. Service connection flow uses `npm run connect-services` to persist and validate Excalidraw server commands. Upgrade flow uses `npm run update`, which fetches stable tags, checks out the newest stable tag in detached mode, rebuilds, retests, refreshes vault wiring idempotently, and stores rollback metadata. Recovery flow uses `npm run rollback` to restore prior references with the same validation and rewiring pattern. Health flow uses `npm run doctor` or `npm run ready-check`, which verifies runtime and wiring integrity before a writing session and returns clear readiness status. Maintainer flow uses `npm run release:tag -- --version vX.Y.Z` to enforce clean release tagging and generate release-note scaffolding.

# Philosophy

Press favors deterministic local behavior over orchestration magic. The system assumes external tools can fail or evolve, so it treats local artifacts as the source of truth and records warnings instead of quietly losing state. That philosophy appears in Excalidraw fallback behavior, stateful idempotency, and strict path guards that prevent writes outside project artifacts.

Press also treats wiring as product, not documentation garnish. A capability that exists only as a command is not enough for this audience; the audience needs natural-language operation that feels immediate. The wiring subsystem closes that gap by making conversation reliably executable and by preventing agents from defaulting to manual `.excalidraw` JSON workflows. Finally, Press uses release discipline to protect creative flow. Stable tags, one-command upgrades, one-command rollback, and binary ready checks reduce operational friction so writing sessions are not derailed by tool uncertainty.
